/*
    Attribution:

    1. Player rotation was adapted from this video tutorial by Web Dev Junkie: https://www.youtube.com/watch?v=_WJSH7NxtRc. Made adjustments to it so that the player's gun pointed to the mouse.
    
    2. Code to move a canvas element from its current position to a target position was borrowed from a html5gamedevs forum post reply written by a user called "Exca". 
       Available from: https://www.html5gamedevs.com/topic/36416-bullet-go-on-mouse-position/
       This was used for getting bullets to move towards where the player and enemies are aiming and for the enemy "chase" behaviour.
       The code for actually creating enemies and bullets and managing them was all written by me.
       I also wrote code to ensure the bullets originated from the barrell of the player's gun. The extent of these modifications are discussed in comments below.

    3. Borrowed code from an article written by Pranchal Katiyar to find out if a user was running the game on a Window's machine. Available from: https://www.geeksforgeeks.org/detect-the-operating-system-of-user-using-javascript/
    4. Media query code for seeing if a user's screen was below a given width was borrowed from W3Schools. Available from: https://www.w3schools.com/howto/howto_js_media_queries.asp
    
       Both 3 and 4 were adapted to be used in conjuction with each other to detect if the user was on a machine that might experience a mouse position bug.
       If the user was running Windows and the screen was also below a certain width then the javascript offsets their recorded mouse position to account for the bug. 
    
    5. Player and enemy art was made by Riley Gombart and is licensed under Creative Commons Attribution 3.0. 
       Art available from: https://opengameart.org/content/animated-top-down-survivor-player 
       License available from: https://creativecommons.org/licenses/by/3.0/

    6. The enemy art was made greyscale using the Grayscale Image Online tool. Available from: https://pinetools.com/grayscale-image

    7. Background music is "Ascent to the Station" by TeknoAXE and is a royalty free piece of music. Available from: http://teknoaxe.com/Home.php

    8. All sound effects were generated by me using the online tool jsfxr. Availbale from: https://sfxr.me/

    9. Font used is Ubuntu by Dalton Maag. Available from: https://fonts.google.com/specimen/Ubuntu

    10. All other HTML, CSS, Javascript, Python and art was written/made by me. I made the tileset in an online tool called Piskel. Available from: https://www.piskelapp.com/

*/

/* 
    Things to note:

    1. The game is very difficult to play with a track pad so I'd recommend using a mouse.

    2. Having the tab zoomed in or out messes up the mouse positioning. Please ensure that your zoom settings are set to their default (i.e. 100% or 1.0) to avoid issues.

    3. There are issues with running the game in Chrome on laptop's running Windows, the details of which are in comments below.
       I implemented a fix but the game runs much better on laptop's running Linux and on Windows Desktops.
       I'd recommend playing it on such a machine for the optimum experience.

    4. The controls are W to go up, S to go down, A to go left, and D to go right. (Or alternatively UP, DOWN LEFT, RIGHT arrow keys)

*/

// Declaring xhttp  and gamertag variables.
let xhttp;
let gamerTag;

// Animation variables.
let canvas;
let context;
let fpsInterval = 1000 / 30; // The denominator is frames per second.
let now;
let then = Date.now();

// Player movement variables.
let moveLeft = false;
let moveRight = false;
let moveUp = false;
let moveDown = false;

// Variables to keep track of the number of bullets and enemies on screen.
let bulletCount = 0;
let enemyCount = 0;

// Declaring and initialising audio assets.
let player_shoot = new Audio("../static/player_shoot.wav");
let enemy_shoot = new Audio("../static/enemy_shoot.wav");
let enemy_death = new Audio("../static/enemy_death.wav");
let player_death = new Audio("../static/player_death.wav");
let music = new Audio("../static/music.mp3");
let select = new Audio("../static/select.wav");

// Start of borrowed code to loop music.
if (typeof music.loop === 'boolean') {
    music.loop = true;
}
else {
    music.addEventListener('ended', function () {
        this.currentTime = 0;
        this.play();
    }, false);
}
// End of borrowed code to loop music.

// All the variables relating to the user's mouse, bullet positions, target positions and offset values for the mouse. 
let targetX;
let targetY;
let distance;
let bulletX;
let bulletY;
let shoulderOffSet;
let mouseX;
let mouseY;
let userOS;
let offSetX;
let offSetY;
let mediaWidth;

// Positions and colours of the buttons on the main menu and the game over menu.
let playXMenu = 800;
let playYMenu = 600;
let playX = 620;
let playY = 470;
let playWidthMenu = 220;
let playWidth = 610;
let playHeightMenu = 60;
let playHeight = 45;
let playColor = "#000000";
let difficultyX = 380;
let difficultyY = 440;
let difficultyWidth = 1090;
let difficultyHeight = 50;
let difficultyColor = "#000000";

// Variables for keeping track of the speed of bullets and the total number of enemies currently in the game.
let bulletSpeed;
let totalEnemies = 1;

/* Array containing the three kinds of enemy behaviours: 
"patrol" where an enemy will move up and down the screen, 
"sit" where the enemy stays in one place, 
and "chase" where the enemy chases the player.
*/
let behaviours = ["patrol", "sit", "chase"];

// Matrix that outlines the positions of tiles from the tileset on the map.
let background = [
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1],
    [4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
];

// Player object.
let player = {
    x: 0,
    y: 0,
    width: 156,
    height: 103,
    frameX: 0,
    frameY: 0,
    rotation: 0
};

// Variable that is used to slow down animations.
let counter = 0;

// Variables that keep track of the game status and difficulty.
let gameOn = true;
let menu = true;
let difficulty = "L E C T U R E R";

// Declaring visual assets
let backgroundImage = new Image();
let playerImage = new Image();
let enemyImage = new Image();

// Mouse object keeping track of the user's mouse's x and y position on the canvas.
let mouse = {
    x: 0,
    y: 0
};

// Variable keeping track of the current round.
let round = 1;

// Each tile in the tileset is 64 x 64 pixels and there are 5 tiles in each row.
let tilesPerRow = 5;
let tileSize = 64;

// Function used to retrive a random number within an inclusive range.
function randint(min, max) {
    return Math.round(Math.random() * (max - min)) + min;
}


class enemy {
    constructor(id, x, y, down, frameX, frameY, rotation, behaviour, targetX, targetY) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.down = down;
        this.frameX = frameX;
        this.frameY = frameY;
        this.rotation = rotation;
        this.behaviour = behaviour;
        this.targetX = targetX;
        this.targetY = targetY;
    }
    move() {
        context.beginPath();
        context.save();
        this.frameY = 1;

        // Start of borrowed code used to rotate a canvas element towards a given point. I modified the code by subtracting 1.73 radians from the rotation so the enemy's gun lined up with the mouse.
        this.rotation = Math.atan2(player.x - this.x, -(player.y - this.y));
        context.translate(this.x, this.y);
        context.rotate(this.rotation - 1.73);
        context.drawImage(enemyImage, player.width * this.frameX, player.height * this.frameY, player.width, player.height, -player.width / 2, -player.height / 2, player.width, player.height);
        // End of borrowed code used to rotate a canvas element towards a given point. I modified the code by subtracting 1.73 radians from the rotation so the enemy's gun lined up with the mouse.

        // If the enemy is in patrol mode then increase their y position until their at the bottom of the screen, then decrease it until they're at the top etc. 
        if (this.behaviour === "patrol" && gameOn === true) {
            if (counter % 3 === 0) {
                this.frameX = (this.frameX + 1) % 4;
            }
            if (this.down === true) {
                this.y += 15;
            } else {
                this.y -= 15;
            }
            if (this.y >= canvas.height - player.height) {
                this.down = false;
            } else if (this.y <= player.height) {
                this.down = true;
            }
        }

        // If the enemy is in chase mode then change their x and y position so that they moved diagonally towards the player's position. 
        if (this.behaviour === "chase" && gameOn === true) {
            if (counter % 3 === 0) {
                this.frameX = (this.frameX + 1) % 4;
            }

            // Start of borrowed code to move a canvas element from its current position to a target position.
            this.targetX = player.x - this.x;
            this.targetY = player.y - this.y;
            distance = Math.sqrt(this.targetX * this.targetX + this.targetY * this.targetY);
            this.targetX /= distance;
            this.targetY /= distance;
            this.x += this.targetX * 15;
            this.y += this.targetY * 15;
            // End of borrowed code to move a canvas element from its current position to a target position.

        }
        context.restore();

        /* 
        This is code I used to modify where the bullet will originate from the enemy so it actually comes out of the gun.
        This is based off of the current rotation of the enemy and I found out how much to offset it by, by setting the enemy's rotation to 0 and using trial and error.
        */
        if (this.rotation > 0 && this.rotation < 2) {
            shoulderOffSet = 15;
        } else {
            shoulderOffSet = 20;
        }
        context.stroke();

        /* 
        Once I have the correct offset for the bullet when the rottaion was 0, this obviously won't keep working once the enemy rotates.
        My solution for this was to take this point of origin i.e. the correct bullet position when rotation = 0,
        and treat it as a point on the circumference of a circle and rotate it based on the current rotation.
        */
        bulletX = shoulderOffSet * Math.cos(this.rotation) - (-80) * Math.sin(this.rotation);
        bulletY = shoulderOffSet * Math.sin(this.rotation) + (-80) * Math.cos(this.rotation);
        targetX = player.x - (this.x + bulletX);
        targetY = player.y - (this.y + bulletY);

        // Start of borrowed code to move a canvas element from its current position towards a target position.
        distance = Math.sqrt(targetX * targetX + targetY * targetY);
        targetX /= distance;
        targetY /= distance;
        // End of borrowed code to move a canvas element from its current position towards a target position.

        // To prevent enemies from constantly firing bullets a random number between 0 and 30 is chosen and if it is 15 then they fire.
        if (randint(0, 30) === 15 && gameOn === true) {

            // Push a new bullet class object to the bullets array with the arguments we have calculated above.
            bullets.push(new bullet(bulletCount, this.x + bulletX, this.y + bulletY, targetX, targetY, "enemy"));

            // Increase bullet count and play enemy shoot sound .
            bulletCount += 1;
            enemy_shoot.play();
        }
    }
}

class bullet {
    constructor(bulletCount, x, y, targetX, targetY, type) {
        this.bulletCount = bulletCount;
        this.x = x;
        this.y = y;
        this.targetX = targetX;
        this.targetY = targetY;
        this.type = type;
    }
    move() {
        // Only animate bullets if the player is alive.
        if (gameOn === true) {
            context.beginPath();

            // Enemy bullets are red and player bullets are blue.
            if (this.type === "enemy") {
                context.fillStyle = "#ff0000";
            } else {
                context.fillStyle = "#0000ff";
            }

            // Move bullets towards their target position.
            context.fillRect(this.x, this.y, 5, 5);
            this.x += this.targetX * bulletSpeed;
            this.y += this.targetY * bulletSpeed;
            context.stroke();
        }
    }
    collision() {

        // If the bullet goes outside the canvas then filter it from the bullets list (i.e. don't animate it anymore) to prevent memory leaks.
        if (this.x >= canvas.width - 10) {
            bullets = bullets.filter(bullet => bullet.bulletCount !== this.bulletCount);
        } else if (this.x <= -10) {
            bullets = bullets.filter(bullet => bullet.bulletCount !== this.bulletCount);
        } else if (this.y >= canvas.height) {
            bullets = bullets.filter(bullet => bullet.bulletCount !== this.bulletCount);
        } else if (this.y <= -20) {
            bullets = bullets.filter(bullet => bullet.bulletCount !== this.bulletCount);
        }
    }
}

function mouseClick(e) {

    // Only allow the player to shoot if they are alive and not in a menu.
    if (gameOn === true && menu === false) {

        // Increase bullet count. 
        bulletCount += 1;

        /* 
        The position of where the user's mouse was when they clicked is recorded.
        The offSetX and offSetY variables are used to fix a bug that is discussed in a later comment.
        */
        mouse.x = e.clientX + offSetX;
        mouse.y = e.clientY + offSetY;

        /* 
        This is code I used to modify where the bullet will originate from the enemy so it actually comes out of the gun.
        This is based off of the current rotation of the enemy and I found out how much to offset it by, by setting the enemy's rotation to 0 and using trial and error.
        */
        if (player.rotation > 0 && player.rotation < 2) {
            shoulderOffSet = 15;
        } else {
            shoulderOffSet = 20;
        }

        /* 
        Once I have the correct offset for the bullet when the rottaion was 0, this obviously won't keep working once the enemy rotates.
        My solution for this was to take this point of origin i.e. the correct bullet position when rotation = 0,
        and treat it as a point on the circumference of a circle and rotate it based on the current rotation.
        */
        bulletX = shoulderOffSet * Math.cos(player.rotation) - (-80) * Math.sin(player.rotation);
        bulletY = shoulderOffSet * Math.sin(player.rotation) + (-80) * Math.cos(player.rotation);
        targetX = mouse.x - (player.x + bulletX);
        targetY = mouse.y - (player.y + bulletY);

        // Start of borrowed code to move a canvas element from its current position towards a target position.
        distance = Math.sqrt(targetX * targetX + targetY * targetY);
        targetX /= distance;
        targetY /= distance;
        bullets.push(new bullet(bulletCount, player.x + bulletX, player.y + bulletY, targetX, targetY, "player"));
        // End of borrowed code to move a canvas element from its current position towards a target position.

        // Play player shoot sound effect.
        player_shoot.play();
    }
}

function mouseMove(e) {

    // Function used to record the player's mouse position when they move it.
    mouse.x = e.clientX + offSetX;
    mouse.y = e.clientY + offSetY;
}

function menuClick(e) {

    // Function used to handle user interaction with menu buttons, only runs if they are actually in a menu.
    if (menu === true) {

        // Record the position of where the mouse was when the user clicked.
        mouseX = e.clientX + offSetX;
        mouseY = e.clientY + offSetY;

        if (gameOn === true) {
            // This runs if the user is interacting with the main menu.

            // This code runs if the player hits the play button. 
            if (!((playXMenu >= mouseX + playWidthMenu) || (playXMenu + playWidthMenu <= mouseX) || (playYMenu >= mouseY + playHeightMenu) || (playYMenu + playHeightMenu <= mouseY))) {

                // If the player has hit play then record the gamer tag they have entered and stop displaying the form.
                let form = document.querySelector("form");
                let nameData = new FormData(form);
                gamerTag = nameData.get("player_name");
                form.style.display = "none";


                // Modifiy the speed of bullets depending on what difficulty the user chose and disables the menu state.
                if (difficulty === "L E C T U R E R") {
                    bulletSpeed = 15;
                } else {
                    bulletSpeed = 30;
                }
                menu = false;

                // Start playing background music and play button select sound effect.
                select.play();
                music.play();
            }

            // This code runs if the player hits the difficulty button. 
            if (!((difficultyX >= mouseX + difficultyWidth) || (difficultyX + difficultyWidth <= mouseX) || (difficultyY >= mouseY + difficultyHeight) || (difficultyY + difficultyHeight <= mouseY))) {

                // Play button select sound effect.
                select.play();

                // This code changes the difficulty to the difficulty it wasn't set to before the user clicked the button.
                if (difficulty === "L E C T U R E R") {
                    difficulty = "S T U D E N T";
                } else {
                    difficulty = "L E C T U R E R";
                }
            }
        }
        else {
            /// This runs if the user is interacting with the "play again menu".
            if (!((playX >= mouseX + playWidth) || (playX + playWidth <= mouseX) || (playY >= mouseY + playHeight) || (playY + playHeight <= mouseY)) && gameOn === false) {
                menu = false;
                gameOn = true;
                select.play();

                // Code to reset the game, i.e. set the round to 0 (it'll be incremented by 1 on game start) and clear the enemies and bullets arrays and reset the enemy count and total. 
                round = 0;
                enemies = [];
                bullets = [];
                enemyCount = 0;
                totalEnemies = 0;
            }
        }
    }
}


function menuMove(e) {

    // This function changes the colour of menu buttons from black to white if the user hovers over them with their mouse.
    if (menu === true) {
        mouseX = e.clientX + offSetX;
        mouseY = e.clientY + offSetY;
        if (gameOn === true) {
            if (!((playXMenu >= mouseX + playWidthMenu) || (playXMenu + playWidthMenu <= mouseX) || (playYMenu >= mouseY + playHeightMenu) || (playYMenu + playHeightMenu <= mouseY))) {
                playColor = "#FFFFFF";
            } else {
                playColor = "#000000";
            }
        } else {
            if (!((playX >= mouseX + playWidth) || (playX + playWidth <= mouseX) || (playY >= mouseY + playHeight) || (playY + playHeight <= mouseY))) {
                playColor = "#FFFFFF";
            } else {
                playColor = "#000000";
            }
        }
        if (!((difficultyX >= mouseX + difficultyWidth) || (difficultyX + difficultyWidth <= mouseX) || (difficultyY >= mouseY + difficultyHeight) || (difficultyY + difficultyHeight <= mouseY))) {
            difficultyColor = "#FFFFFF";
        } else {
            difficultyColor = "#000000";
        }
    } else if (gameOn === false) {

    }
}

// These arrays keep track of enemy and bullet class objects currently in the game.
let enemies = [];
let bullets = [];

// Wait for DOMContent to be loaded then run the init function which starts the game loop.
document.addEventListener("DOMContentLoaded", init, false);

function init() {

    /*
        This is code I borrowed  and adapted to fix an odd bug I encountered where the mouse position on the canvas was being recorded incorrectly on laptop's running Chrome on Windows.
        It works fine on laptop's running Chrome on Ubuntu but strangely enough it works fine on a desktop running Chrome on Windows. Very inconsistent behaviour. 
        Only difference between my Window's desktop and Window's laptop that is really relevant is the larger screen but that doesn't explain it working on smaller screened machines running Ubuntu.

        Regardless anyways I combined two solutions I found on the web. One that allowed me to tell what operating system the user was running and another that let me know what size screen they had,
        using a media query. The offSetX and offSetY variables that fix the skewed mouse position were calculated through trial and error. The issue where a user couldn't select menu buttons without hovering
        far below them has been fixed and the user rotation is smoother than when it was broken. However, the player rotation on a machine affected by the bug is notably more janky than that of one,
        which is not. For this reason, I recommend testing the game on a machine that isn't for the full experience.

    */
    if (navigator.appVersion.indexOf("Win") != -1 && window.matchMedia("(max-width: 1900px)").matches) {
        offSetX = 75;
        offSetY = 200;

        // Log that the user's machine experiences the bug in the console.
        console.log("This machine experiences the mouse position bug so fixes have been applied. For a better experience of the game we recommend using either a Desktop running Windows or a laptop running Linux.");
    } else {

        offSetX = 0;
        offSetY = 0;

        // Log that the user's machine doesn't experience the bug in the console. 
        console.log("This machine does not experience the mouse position bug. This is the optimum experience!");
    }
    // End of borrowed and adapted code. 

    // Adding event listeners for user input.
    document.addEventListener("mousedown", mouseClick, false);
    document.addEventListener("mousemove", mouseMove, false);
    window.addEventListener("keydown", activate, false);
    window.addEventListener("keyup", deactivate, false);
    document.addEventListener("mousedown", menuClick, false);
    document.addEventListener("mousemove", menuMove, false);

    // Loading player, enemy & background image assets.
    playerImage.src = "../static/player.png";
    backgroundImage.src = "../static/tileset.png";
    enemyImage.src = "../static/enemy.png";

    // Select the canvas element and set its width and height.
    canvas = document.querySelector("canvas");
    canvas.width = 1848;
    canvas.height = 975;

    // Get the 2d context to allow us to animate.
    context = canvas.getContext("2d");

    // Set player starting coridinates to the top of the screen and half way across it.
    player.x = 900;
    player.y = 0;

    /* 
    Spawning first enemy at a random location in sit mode.
    This is because other behaviours such patrol for example can lead to the enemy being right on top of the player on spawn. 
    */
    enemies.push(new enemy(0, randint(64, 1728), randint(64, 896), true, 0, 0, 0, "sit", 0, 0));

    // Call draw function whcih runs 60 times a second.
    draw();
}

function draw() {
    // Request animation frame to allow us to animate.
    window.requestAnimationFrame(draw);

    // Code to prevent the game running faster/slower for users using faster/slower machines.
    let now = Date.now();
    let elapsed = now - then;
    if (elapsed <= fpsInterval) {
        return;
    }
    then = now - (elapsed % fpsInterval);
    if (menu === true && gameOn === true) {
        // If the game has just been started then display the menu.
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.font = "75px Ubuntu";
        context.fillText("G R E Y S C A L E ", canvas.width / 2.85, canvas.height / 3.25);
        context.save();
        context.fillStyle = difficultyColor;
        context.fillText(`D I F F I C U L T Y :  ${difficulty}`, canvas.width / 5, canvas.height / 2.25);
        context.restore();
        context.save();
        context.fillStyle = playColor;
        context.fillText("P L A Y", canvas.width / 2.3, canvas.height / 1.5);
        context.restore();
    }
    else {
        // If there are no more enemies left then move to the next round. Each round the total enemies spawned increases by 1.
        if (enemies.length === 0) {
            round += 1;
            totalEnemies += 1;
            for (let i = 0; i < totalEnemies; i++) {

                enemyCount += 1;

                // Enemies are spawned in a random location and with a random behaviour.
                enemies.push(new enemy(enemyCount, randint(64, 1728), randint(64, 896), true, 0, 0, 0, behaviours[randint(0, 2)], 0, 0));
            }
        }

        context.beginPath();

        // This code draws the background from the tileset.
        context.clearRect(0, 0, canvas.width, canvas.height);
        for (let r = 0; r < 20; r += 1) {
            for (let c = 0; c < 32; c += 1) {
                let tile = background[r][c];
                if (tile >= 0) {
                    let tileRow = Math.floor(tile / tilesPerRow);
                    let tileCol = Math.floor(tile % tilesPerRow);
                    context.drawImage(backgroundImage,
                        tileCol * tileSize, tileRow * tileSize, tileSize, tileSize,
                        c * tileSize, r * tileSize, tileSize, tileSize);
                }
            }
        }

        if (gameOn === true) {
            // Start of borrowed code used to rotate a canvas element towards a given point. I modified the code by subtracting 1.73 radians from the rotation so the enemy's gun lined up with the mouse.
            player.rotation = Math.atan2(mouse.x - player.x, -(mouse.y - player.y));
            context.save();
            context.translate(player.x, player.y);
            context.rotate(player.rotation - 1.73);
            context.drawImage(playerImage, player.width * player.frameX, player.height * player.frameY, player.width, player.height, -player.width / 2, -player.height / 2, player.width, player.height);
            context.restore();
            // End of borrowed code used to rotate a canvas element towards a given point. I modified the code by subtracting 1.73 radians from the rotation so the enemy's gun lined up with the mouse.
        }

        // Draw the round number in the top left corner of the screen.
        context.fillStyle = "#ff0000";
        context.font = "30px Ubuntu";
        context.fillText(`Round: ${round}`, 10, 50);
        context.stroke();

        // This for loop goes through every enemy class object in the enemies array and runs its move method which animates it and calls the bullet_hit function on it.
        for (let i = 0; i < enemies.length; i++) {
            enemies[i].move();
            bullet_hit(enemies[i]);
        }

        // This loop goes through every bullet class object in the bullets array and runs its move method which animates it and checks to see if its hit the player or has left the screen.
        for (let i = 0; i < bullets.length; i++) {
            bullets[i].move();
            if (!((player.x >= bullets[i].x + (player.width - 50)) || (player.x + (player.width - 50) <= bullets[i].x) || (player.y >= bullets[i].y + (player.height - 100)) || (player.y + (player.height - 30) <= bullets[i].y) || bullets[i].type === "player")) {

                // This code runs if the bullet is an enemy bullet and has hit the player. In this case the game is over and the "play again" menu will be displayed and the bullet filtered from the bullets array to prevent memory leaks.
                gameOn = false;
                menu = true;
                bullets = bullets.filter(bullet => bullet.bulletCount !== bullets[i].bulletCount);

                // This code sends the difficulty the user is playing, their gamer tag, and the round they reached to the store_round function.
                let data = new FormData();
                data.append("round", round);
                data.append("gamerTag", gamerTag);
                data.append("difficulty", difficulty);
                xhttp = new XMLHttpRequest();
                xhttp.open("POST", "/~mm55/cgi-bin/ca2/run.py/store_round", true);
                xhttp.send(data);

                // Play player death sound effect.
                player_death.play("../static/player_death.wav");
            } else {

                // If the bullet hasn't hit the player then check to see if it has left the screen.
                bullets[i].collision();
            }
        }

        // If the player is moveing in a given direction then change its x / y cordinates and its Y animation frame.
        if (moveLeft) {
            player.x = player.x - 15;
            player.frameY = 1;
        }
        if (moveRight) {
            player.x = player.x + 15;
            player.frameY = 2;
        }
        if (moveUp) {
            player.y = player.y - 15;
            player.frameY = 3;
        }

        if (moveDown) {
            player.y = player.y + 15;
            player.frameY = 4;
        }

        // Update the player's X animation frame depending on what direction they're moving in. The counter variable allows for the animation to be slower as it needs to be a multiple of 3 for the code to run.
        if ((moveLeft || moveRight || moveUp || moveDown) && !(moveLeft && moveRight || moveUp && moveDown) && counter % 3 === 0) {
            player.frameX = (player.frameX + 1) % 4;
        }

        // Increasing the counter by 1 each time we run the draw function.
        counter++;

        // Handle border collissions so the player can not move off of the screen.
        if (player.x >= canvas.width - 128) {
            if (player.y >= canvas.height - 90) {
                player.y -= 15;
            } else if (player.y <= 128) {
                player.y += 15;
            }
            player.x -= 15;
        } else if (player.x <= 128) {
            if (player.y >= canvas.height - 90) {
                player.y -= 15;
            } else if (player.y <= 128) {
                player.y += 15;
            }
            player.x += 15;
        } else if (player.y >= canvas.height - 90) {
            player.y -= 15;
        } else if (player.y <= 128) {
            player.y += 15;
        }

        // If the game is over then display the "play again" menu.
        if (gameOn === false) {
            context.font = "75px Ubuntu";
            context.save();
            context.fillStyle = playColor;
            context.fillText("P L A Y  A G A I N ?", canvas.width / 3, canvas.height / 1.9);
            context.restore();
        }
    }
}

function activate(event) {
    // Function to handle player pressing keys down which causes them to move. Player movement is controlled with WASD and/or arrow keys.
    let key = event.key;
    if (gameOn === true) {
        if (key === "ArrowLeft" || key === "a") {
            moveLeft = true;
        } else if (key === "ArrowRight" || key === "d") {
            moveRight = true;
        } else if (key === "ArrowUp" || key === "w") {
            moveUp = true;
        } else if (key === "ArrowDown" || key === "s") {
            moveDown = true;
        }
    }
}

function deactivate(event) {
    // Function to handle player releasing keys which stops them from moving. Player movement is controlled with WASD and/or arrow keys.
    let key = event.key;
    if (key === "ArrowLeft" || key === "a") {
        moveLeft = false;
    } else if (key === "ArrowRight" || key === "d") {
        moveRight = false;
    } else if (key === "ArrowUp" || key === "w") {
        moveUp = false;
    } else if (key === "ArrowDown" || key === "s") {
        moveDown = false;
    }
}

function bullet_hit(hit_enemy) {

    // Goes through a for loop to see if any of the player's bullets has hit hit_enemy. If they have then the enemy dies.
    for (let i = 0; i < bullets.length; i++) {
        if (!((hit_enemy.x >= bullets[i].x + (player.width - 50)) || (hit_enemy.x + (player.width - 50) <= bullets[i].x) || (hit_enemy.y >= bullets[i].y + (player.height - 100)) || (hit_enemy.y + (player.height - 30) <= bullets[i].y) || bullets[i].type === "enemy")) {
            enemyCount -= 1;

            // Removes hit_enemy from the enemy array to avoid memory leaks.
            enemies = enemies.filter(enemy => enemy.id !== hit_enemy.id);

            // Plays enemy death sound effect
            enemy_death.play();

            // Removes the bullet that hit hit_enemy to avoid memory leaks.
            bullets = bullets.filter(bullet => bullet.bulletCount !== bullets[i].bulletCount);
        }
    }
}